# -*- coding: utf-8
# BPython3 will try to use 'ascii' if you don't explicitly name the encoding.

# Add auto-completion and a stored history file of commands to your Python
# interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
# bound to the Tab key.
#
# Store the file in ~/.pystartup, and set an environment variable to point
# to it:  "export PYTHONSTARTUP=~/.pystartup" in bash.

# Save globals list, for reporting custom startup funcs later.
__existing = set(dir())

import atexit
import readline
import rlcompleter

# Modules that will be available every time the interpreter starts.
import sys  # noqa
from datetime import datetime  # noqa
import json  # noqa
import os
import platform  # noqa
import re  # noqa
import time  # noqa


# Setup history ---------------------------------------------------------------
historyPath = os.path.expanduser('~/.pyhistory')


def __gethistory():
    """ Print the lines in the history file. """
    historyPath = os.path.expanduser('~/.pyhistory')
    if os.path.isfile(historyPath):
        try:
            with open(historyPath, 'r') as f:
                return [l.rstrip() for l in f.readlines()]
        except EnvironmentError as ex:
            errfmt = '\nUnable to read history file: {}\n{}'
            print(errfmt.format(historyPath, ex))
            return []
    print('\nNo history file found: {}'.format(historyPath))
    return []


def __printhistory():
    hist = __gethistory()
    if hist:
        print('\nPython history:\n')
        print('\n'.join(hist))
    else:
        print('\nNo history to print.')


def save_history(historyPath=historyPath):
    import readline
    readline.write_history_file(historyPath)

if os.path.exists(historyPath):
    readline.read_history_file(historyPath)

# Register save-history on exit.
atexit.register(save_history)

# Enable auto-complete for variable names and modules
readline.parse_and_bind('tab: complete')

# Cj's colorizer for linux, will persist. -------------------------------------
# Uses the colr module, but will fall back to the old ColorCodes class.
try:
    from colr import color, Colr as C  # noqa
except ImportError:
    print('Colr module was not available, using ColorCodes() instead.')

    class ColorCodes(object):

        """ This class colorizes text for an ansi terminal.
            This is a stripped-down version made especially for this
            Python Startup file. It has only the features needed for basic
            interpreter usage.
        """

        def __init__(self):
            # Linux style color code numbers.
            self.codes = {
                'fore': {
                    'black': '30', 'red': '31',
                    'green': '32', 'yellow': '33',
                    'blue': '34', 'magenta': '35',
                    'cyan': '36', 'white': '37',
                    'reset': '39'},
                'back': {
                    'black': '40', 'red': '41', 'green': '42',
                    'yellow': '43', 'blue': '44',
                    'magenta': '45', 'cyan': '46', 'white': '47',
                    'reset': '49'},
                'style': {
                    'bold': '1', 'bright': '1', 'dim': '2',
                    'normal': '22', 'none': '22',
                    'reset_all': '0',
                    'reset': '0'},
            }

            # Format string for full color code.
            self.codeformat = '\033[{}m'
            self.codefmt = lambda s: self.codeformat.format(s)

            # Shortcuts to most used functions.
            self.word = self.colorword

        def color_code(self, fore=None, back=None, style=None):
            """ Return the code for this style/color
                Fixes style positions so a RESET doesn't affect a following
                color.
            """

            codes = []
            userarg = {'style': style, 'back': back, 'fore': fore}
            for stype in userarg:
                style = userarg[stype].lower() if userarg[stype] else None
                # Get code number for this style.
                code = self.codes[stype].get(style, None)
                if code:
                    # Reset codes come first (or they will override others)
                    if style in ('none', 'normal', 'reset', 'reset_all'):
                        codes.insert(0, self.codefmt(code))
                    else:
                        codes.append(self.codefmt(code))
            return ''.join(codes)

        def colorize(self, text=None, fore=None, back=None, style=None):
            """ Return text colorized.
                fore,back,style  : Name of fore or back color, or style name.
            """
            if text is None:
                text = ''
            return '{codes}{txt}'.format(codes=self.color_code(style=style,
                                                               back=back,
                                                               fore=fore),
                                         txt=text)

        def colorword(self, text=None, fore=None, back=None, style=None):
            """ Same as colorize, but adds a style->reset_all after it. """
            if text is None:
                text = ''
            colorized = self.colorize(
                text=text,
                style=style,
                back=back,
                fore=fore)
            s = '{colrtxt}{reset}'.format(
                colrtxt=colorized,
                reset=self.color_code(style='reset_all'))
            return s

    # Alias, convenience function for ColorCodes().
    # We are using these now, but also keeping them around for use in the
    # interpreter.
    color = C = ColorCodes().colorword

# Globals that will persist ---------------------------------------------------
RAGESTR = ''.join((
    str(C('(╯°□°)╯', fore='blue')),
    '︵',
    str(C('┻━┻', fore='yellow'))
))


class Rager(object):

    def __repr__(self):
        return str(self)

    def __str__(self):
        sys.stdout.write(RAGESTR)
        return ''

RAGE = Rager()


# Functions that will persist.
def import_scripts(path=None):
    """ Add /home/cj/scripts to sys.path. """
    scriptdir = '/home/cj/scripts'
    path = os.path.join(scriptdir, path) if path else scriptdir
    sys.path.insert(1, path)
    sys.stdout.write('\nNew import path: {}\n'.format(path))


def printa(o, private=False):
    """ Print all attributes for an object. """
    print(color(
        '{}:'.format(getattr(o, '__name__', getattr(o.__class__, '__name__'))),
        fore='blue',
        style='bright'))
    for a in dir(o):
        if (not private) and a.startswith('_'):
            continue
        try:
            val = getattr(o, a)
            val = getattr(val, '__doc__', '').strip() or val
        except Exception as ex:
            val = '<Unable to get value: {}>'.format(ex)
        print('    {}: {}'.format(
            color(a, fore='cyan'),
            color(str(val), fore='green')))


def printc(s, fore=None, back=None, style=None):
    """ Print with color, using fore, back, and style arguments. """
    print(color(s, fore=fore, back=back, style=style))


def printjson(o, sort_keys=False):
    """ Shortcut to print(json.dumps(o, indent=4, sort_keys=sort_keys)) """
    print(json.dumps(o, indent=4, sort_keys=sort_keys))


def printp(d, indent=0):
    """ Print a dict/list/tuple, with pretty formatting. """
    if isinstance(d, dict):
        for k, v in d.items():
            print('{}{}:'.format(' ' * indent, k))
            if isinstance(v, dict):
                printp(v, indent=indent + 4)
            elif isinstance(v, (list, tuple)):
                printp(v, indent=indent + 4)
            else:
                print('{}{}'.format(' ' * (indent + 4), v))
    elif isinstance(d, (list, tuple)):
        for itm in d:
            if isinstance(itm, (list, tuple)):
                printp(itm, indent=indent + 4)
            else:
                print('{}{}'.format(' ' * indent, d))
    else:
        print('{}{}'.format(' ' * indent, d))

# Set the prompt text. PS1 is the main prompt, PS2 is continuations.. ---------
sys.ps1 = '>>> '
sys.ps2 = '... '
# Use color prompts when available.
# Disabled, BPython3 chokes on these colored prompts:
# if os.environ.get('TERM', '') in ('xterm', 'vt100'):
#     sys.ps1 = color(sys.ps1, fore='green')
#     sys.ps2 = color(sys.ps2, fore='blue')

# Delete these so they won't automatically be available on startup.
del atexit, readline, rlcompleter, save_history, historyPath


def preloads():
    """ Print all custom items loaded in .pystartup. """
    if __preloads:
        print('\nPre-loaded items:\n    {}\n'.format(
            ', '.join(
                sorted(s for s in __preloads if not s.startswith('_'))
            )
        ))
        return len(__preloads)
    return 0

# Report any custom funcs added by .pystartup.
__preloads = set(dir()).difference(__existing)
del __existing
preloads()
