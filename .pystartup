# -*- coding: utf-8
# BPython3 will try to use 'ascii' if you don't explicitly name the encoding.

# Add auto-completion and a stored history file of commands to your Python
# interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
# bound to the Tab key.
#
# Store the file in ~/.pystartup, and set an environment variable to point
# to it:  "export PYTHONSTARTUP=~/.pystartup" in bash.

# Save globals list, for reporting custom startup funcs later.
__existing = set(dir())

import atexit       # noqa
import readline     # noqa
import rlcompleter  # noqa

# Modules that will be available every time the interpreter starts.
import sys                     # noqa
from datetime import datetime  # noqa
import importlib               # noqa
import json                    # noqa
import os                      # noqa
import platform                # noqa
import re                      # noqa
import time                    # noqa


# Setup history --------------------------------------------------------------
historyPath = os.path.expanduser('~/.pyhistory')


def __gethistory():
    """ Print the lines in the history file. """
    historyPath = os.path.expanduser('~/.pyhistory')
    if os.path.isfile(historyPath):
        try:
            with open(historyPath, 'r') as f:
                return [l.rstrip() for l in f.readlines()]
        except EnvironmentError as ex:
            errfmt = '\nUnable to read history file: {}\n{}'
            print(errfmt.format(historyPath, ex))
            return []
    print('\nNo history file found: {}'.format(historyPath))
    return []


def __printhistory():
    hist = __gethistory()
    if hist:
        print('\nPython history:\n')
        print('\n'.join(hist))
    else:
        print('\nNo history to print.')


def save_history(historyPath=historyPath):
    import readline
    readline.write_history_file(historyPath)

if os.path.exists(historyPath):
    readline.read_history_file(historyPath)

# Register save-history on exit.
atexit.register(save_history)

# Enable auto-complete for variable names and modules
readline.parse_and_bind('tab: complete')


# Cj's colorizer for linux, will persist. ------------------------------------
# Uses the colr module, but will fall back to the old ColorCodes class.
def noop_color(text=None, fore=None, back=None, style=None):
    """  A function that does nothing, to disable color() and C(). """
    return text

try:
    from colr import color, Colr as C  # noqa
except ImportError:
    print('Colr module was not available, using ColorCodes() instead.')

    class ColorCodes(object):

        """ This class colorizes text for an ansi terminal.
            This is a stripped-down version made especially for this
            Python Startup file. It has only the features needed for basic
            interpreter usage.
        """

        def __init__(self):
            # Linux style color code numbers.
            self.codes = {
                'fore': {
                    'black': '30', 'red': '31',
                    'green': '32', 'yellow': '33',
                    'blue': '34', 'magenta': '35',
                    'cyan': '36', 'white': '37',
                    'reset': '39'},
                'back': {
                    'black': '40', 'red': '41', 'green': '42',
                    'yellow': '43', 'blue': '44',
                    'magenta': '45', 'cyan': '46', 'white': '47',
                    'reset': '49'},
                'style': {
                    'bold': '1', 'bright': '1', 'dim': '2',
                    'normal': '22', 'none': '22',
                    'reset_all': '0',
                    'reset': '0'},
            }

            # Format string for full color code.
            self.codeformat = '\033[{}m'
            self.codefmt = lambda s: self.codeformat.format(s)

            # Shortcuts to most used functions.
            self.word = self.colorword

        def color_code(self, fore=None, back=None, style=None):
            """ Return the code for this style/color
                Fixes style positions so a RESET doesn't affect a following
                color.
            """

            codes = []
            userarg = {'style': style, 'back': back, 'fore': fore}
            for stype in userarg:
                style = userarg[stype].lower() if userarg[stype] else None
                # Get code number for this style.
                code = self.codes[stype].get(style, None)
                if code:
                    # Reset codes come first (or they will override others)
                    if style in ('none', 'normal', 'reset', 'reset_all'):
                        codes.insert(0, self.codefmt(code))
                    else:
                        codes.append(self.codefmt(code))
            return ''.join(codes)

        def colorize(self, text=None, fore=None, back=None, style=None):
            """ Return text colorized.
                fore,back,style  : Name of fore or back color, or style name.
            """
            if text is None:
                text = ''
            return '{codes}{txt}'.format(codes=self.color_code(style=style,
                                                               back=back,
                                                               fore=fore),
                                         txt=text)

        def colorword(self, text=None, fore=None, back=None, style=None):
            """ Same as colorize, but adds a style->reset_all after it. """
            if text is None:
                text = ''
            colorized = self.colorize(
                text=text,
                style=style,
                back=back,
                fore=fore)
            s = '{colrtxt}{reset}'.format(
                colrtxt=colorized,
                reset=self.color_code(style='reset_all'))
            return s

    # Alias, convenience function for ColorCodes().
    # We are using these now, but also keeping them around for use in the
    # interpreter.
    color = C = ColorCodes().colorword

# Remove color functions if running in bpython (trips on escape codes).
if __name__ == '__console__':
    color = C = noop_color

# Globals that will persist --------------------------------------------------
SCRIPTS = '/home/cj/scripts'

RAGESTR = ''.join((
    str(C('(╯°□°)╯', fore='blue')),
    '︵',
    str(C('┻━┻', fore='yellow'))
))


class Rager(object):

    def __repr__(self):
        return str(self)

    def __str__(self):
        sys.stdout.write(RAGESTR)
        return ''

RAGE = Rager()


# Functions that will persist.
def compile_file(filename):
    """ Compiles a module by file name, and returns the code object.
        You can `exec()` the object in the global scope to 'source' it.

        Scripts are executed as if they were ran from the command line,
        as in __name__ == '__main__'.
    """
    with open(filename, 'r') as f:
        return compile(f.read(), filename, 'exec')


def compile_script(filename):
    """ Compiles a module found in SCRIPTS dir, and returns the code object.
        You can `exec()` the object in the global scope to 'source' it.

        Scripts are executed as if they were ran from the command line,
        as in __name__ == '__main__'.
    """
    if os.path.exists(filename):
        return compile_file(filename)
    scriptdir = os.path.join(SCRIPTS, filename)
    if os.path.exists(scriptdir):
        return compile_file(scriptdir)
    raise FileNotFoundError('Cannot find this file: {}'.format(filename))


def import_scripts(path=None):
    """ Add /home/cj/scripts to sys.path. """
    path = os.path.join(SCRIPTS, path) if path else scriptdir
    sys.path.insert(1, path)
    sys.stdout.write('\nNew import path: {}\n'.format(path))


def import_script(path):
    """ Import a module from my the SCRIPTS directory.
        The module will be placed in the global scope.
    """
    modpath, filename = os.path.split(path)
    modname = os.path.splitext(filename)[0]
    import_scripts(modpath)
    try:
        modl = importlib.import_module(modname)
    except ImportError as ex:
        sys.stderr.write('\nFailed to import `{}`: {}\n'.format(modname, ex))
    else:
        globals()[modname] = modl
        sys.stdout.write('\nImported module: {}\n'.format(modname))


def printa(o, private=False):
    """ Print all attributes for an object. """
    print(
        color(
            '{}:'.format(
                getattr(o, '__name__', getattr(o.__class__, '__name__'))
            ),
            fore='blue',
            style='bright'
        )
    )
    for a in dir(o):
        if (not private) and a.startswith('_'):
            continue
        try:
            val = getattr(o, a)
            val = getattr(val, '__doc__', '').strip() or val
        except AttributeError as ex:
            val = '<Unable to get value: {}>'.format(ex)
        valstr = str(val)
        print('{}    {}: {}'.format(
            '\n' if '\n' in valstr else '',
            color(a, fore='cyan'),
            color(valstr, fore='green')))


def printc(s, fore=None, back=None, style=None):
    """ Print with color, using fore, back, and style arguments. """
    print(color(s, fore=fore, back=back, style=style))


def printjson(o, sort_keys=False):
    """ Shortcut to print(json.dumps(o, indent=4, sort_keys=sort_keys)) """
    print(json.dumps(o, indent=4, sort_keys=sort_keys))


def printp(d, indent=0):
    """ Print a dict/list/tuple, with pretty formatting. """
    if isinstance(d, dict):
        for k, v in d.items():
            print('{}{}:'.format(' ' * indent, k))
            if isinstance(v, dict):
                printp(v, indent=indent + 4)
            elif isinstance(v, (list, tuple)):
                printp(v, indent=indent + 4)
            else:
                print('{}{}'.format(' ' * (indent + 4), v))
    elif isinstance(d, (list, tuple)):
        for itm in d:
            if isinstance(itm, (list, tuple)):
                printp(itm, indent=indent + 4)
            else:
                print('{}{}'.format(' ' * indent, d))
    else:
        print('{}{}'.format(' ' * indent, d))

# Set the prompt text. PS1 is the main prompt, PS2 is continuations.. --------
sys.ps1 = '>>> '
sys.ps2 = '... '
# Use color prompts when available.
# Disabled, BPython3 chokes on these colored prompts:
# if os.environ.get('TERM', '') in ('xterm', 'vt100'):
#     sys.ps1 = color(sys.ps1, fore='green')
#     sys.ps2 = color(sys.ps2, fore='blue')

# Delete these so they won't automatically be available on startup.
del atexit, readline, rlcompleter, save_history, historyPath


def preloads():
    """ Print all custom items loaded in .pystartup. """
    if __preloads:
        print('\nPre-loaded items:\n    {}\n'.format(
            ', '.join(
                sorted(s for s in __preloads if not s.startswith('_'))
            )
        ))
        return len(__preloads)
    return 0

# Report any custom funcs added by .pystartup.
__preloads = set(dir()).difference(__existing)
del __existing
preloads()
